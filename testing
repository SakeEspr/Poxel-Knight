import pygame
import os
import random

pygame.init()

# ---------- CONFIG ----------
SCREEN_WIDTH, SCREEN_HEIGHT = 1200, 800
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Poxxel')
FPS, clock = 60, pygame.time.Clock()

# ---------- GAME VARIABLES ----------
GRAVITY = 0.75
DASH_SPEED, DASH_TIME, DASH_COOLDOWN = 14, 12, 40
JUMP_SPEED, MAX_JUMP_TIME, JUMP_HOLD_FORCE = -11, 15, -0.5
ATTACK_RANGE, ATTACK_WIDTH, ATTACK_HEIGHT, ATTACK_DAMAGE = 60, 40, 50, 10
WELL_WIDTH, WELL_HEIGHT = 300, 100
BG = (255, 200, 200)
RED, GREEN, WHITE, BLACK = (255, 0, 0), (0, 255, 0), (255, 255, 255), (0, 0, 0)

enemy1_JUMP_CHANCE = 0.03
static_background = None
roof_restored = False
moving_left = moving_right = DEBUG_HITBOXES = waiting_for_reentry = False
middle_platforms_visible = True
waiting_for_reentry_counter = 0
vertical_platforms = []
vertical_platforms_active = False
enemy1_dead_handled = boss_env_suppressed = False

# Load and convert background
try:
    Back = pygame.image.load('img/BG/New_BG.png')
    Back = pygame.transform.scale(Back, (SCREEN_WIDTH, SCREEN_HEIGHT)).convert()
except:
    Back = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
    Back.fill(BG).convert()

# Load well images
def load_img(path, size=None, alpha=True):
    try:
        img = pygame.image.load(path)
        if size: img = pygame.transform.scale(img, size)
        return img.convert_alpha() if alpha else img.convert()
    except:
        return None

well_img = load_img('img/BG/well1.png', (WELL_WIDTH, WELL_HEIGHT))
well2_img = load_img('img/BG/well2.png', (WELL_WIDTH, WELL_HEIGHT))

# Load health masks
MASK_SCALE = 2
mask_filled = load_img('img/player/Mask/mask_filled.png')
mask_empty = load_img('img/player/Mask/mask_empty.png')
if mask_filled:
    mask_filled = pygame.transform.scale(mask_filled, (int(mask_filled.get_width() * MASK_SCALE), int(mask_filled.get_height() * MASK_SCALE))).convert_alpha()
    mask_empty = pygame.transform.scale(mask_empty, (int(mask_empty.get_width() * MASK_SCALE), int(mask_empty.get_height() * MASK_SCALE))).convert_alpha()
else:
    mask_filled = pygame.Surface((30, 30))
    mask_filled.fill(GREEN).convert()
    mask_empty = pygame.Surface((30, 30))
    mask_empty.fill(RED).convert()

def draw_health_masks(current_masks, max_masks=5):
    for i in range(max_masks):
        x = 20 + i * (mask_filled.get_width() + 10)
        screen.blit(mask_filled if i < current_masks else mask_empty, (x, 20))

# ---------- PLATFORM CLASS ----------
class Platform(pygame.sprite.Sprite):
    def __init__(self, x, y, w, h, invisible=False):
        super().__init__()
        self.image = pygame.Surface((w, h))
        if invisible: self.image.set_alpha(0)
        self.image = self.image.convert_alpha() if invisible else self.image.convert()
        self.rect = pygame.Rect(x, y, w, h)

platform_group = pygame.sprite.Group()

# Platform setup
VPLAT_WIDTH, VPLAT_HEIGHT, VPLAT_Y = 25, 100, 600
VPLAT_LEFT_X, VPLAT_RIGHT_X = 475, 700
GROUND_Y, GROUND_H = 650, 80

left_x, left_w = 0, max(0, int(VPLAT_LEFT_X))
mid_x, mid_w = int(VPLAT_LEFT_X), max(0, int(VPLAT_RIGHT_X - VPLAT_LEFT_X))
right_x, right_w = int(VPLAT_RIGHT_X), max(0, SCREEN_WIDTH - int(VPLAT_RIGHT_X))

platforms = [
    (left_x, GROUND_Y, left_w, GROUND_H, True),
    (mid_x, GROUND_Y, mid_w, GROUND_H, True),
    (right_x, GROUND_Y, right_w, GROUND_H, True),
    (0, 700, SCREEN_WIDTH, 200, False),
]

for p_data in platforms:
    platform = Platform(*p_data)
    platform_group.add(platform)
    if p_data[0] == mid_x and p_data[2] == mid_w and p_data[3] == GROUND_H:
        middle_ground_platform = platform

ROOF_Y, ROOF_H = -350, 400
for roof_data in [(left_x, ROOF_Y, left_w, ROOF_H, True), (mid_x, ROOF_Y, mid_w, ROOF_H, True), (right_x, ROOF_Y, right_w, ROOF_H, True)]:
    roof_plat = Platform(*roof_data)
    platform_group.add(roof_plat)
    if roof_data[0] == mid_x and roof_data[2] == mid_w:
        middle_roof_platform = roof_plat

def create_vertical_platforms():
    global vertical_platforms_active, vertical_platforms
    if vertical_platforms_active: return
    
    p1 = Platform(VPLAT_LEFT_X, VPLAT_Y, VPLAT_WIDTH, VPLAT_HEIGHT, True)
    p2 = Platform(VPLAT_RIGHT_X, VPLAT_Y, VPLAT_WIDTH, VPLAT_HEIGHT, True)
    
    for p in [p1, p2]:
        orig_rect = p.rect.copy()
        try: b = p.image.get_bounding_rect()
        except: b = p.image.get_rect()
        p.rect = pygame.Rect(orig_rect.x + b.x, orig_rect.y + b.y, b.width, b.height)
        p._visual_rect = orig_rect
        platform_group.add(p)
    
    vertical_platforms = [p1, p2]
    vertical_platforms_active = True

def remove_vertical_platforms():
    global vertical_platforms_active, vertical_platforms
    for p in list(vertical_platforms):
        try: platform_group.remove(p)
        except: pass
    vertical_platforms = []
    vertical_platforms_active = False

def create_static_background(black_bg=False):
    bg_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
    bg_surface.fill((0, 0, 0) if black_bg else BG) if black_bg else bg_surface.blit(Back, (0, 0))
    for platform in platform_group:
        if black_bg or platform.image.get_alpha() != 0:
            bg_surface.blit(platform.image, platform.rect)
    return bg_surface.convert()

static_background = create_static_background()

def draw_bg():
    screen.blit(static_background, (0, 0))

def draw_well():
    if well_img: screen.blit(well_img, (450, 575))

def draw_well_front():
    if well2_img: screen.blit(well2_img, (450, 612))

def enemy1_dead():
    create_vertical_platforms()
    for plat, name in [(middle_ground_platform, 'ground'), (middle_roof_platform, 'roof')]:
        try:
            platform_group.remove(plat)
            static_background = create_static_background()
        except: pass

# ---------- LOAD ANIMATIONS ----------
def load_animations(char_type, types, scale, color=(0, 100, 200)):
    animation_list = []
    for anim in types:
        temp_list = []
        try:
            path = f'img/{char_type}/{anim}'
            if os.path.exists(path):
                for i in range(len(os.listdir(path))):
                    img = load_img(f'{path}/{i}.png', alpha=True)
                    img = pygame.transform.scale(img, (int(img.get_width() * scale), int(img.get_height() * scale)))
                    temp_list.append(img)
            else:
                for _ in range(4):
                    img = pygame.Surface((70 if char_type == 'enemy' else 60, 90 if char_type == 'enemy' else 80))
                    temp_list.append(img.fill(color).convert())
        except:
            for _ in range(4):
                img = pygame.Surface((70 if char_type == 'enemy' else 60, 90 if char_type == 'enemy' else 80))
                temp_list.append(img.fill(color).convert())
        animation_list.append(temp_list)
    return animation_list

# ---------- ENEMY CLASS ----------
class Enemy1(pygame.sprite.Sprite):
    def __init__(self, x, y, scale, speed):
        super().__init__()
        self.alive = True
        self.speed, self.direction, self.flip = speed * 2.5, -1, False
        self.max_health, self.health = 120, 120
        self.vel_y, self.in_air = 0, True
        self.patrol_distance, self.start_x = 500, x
        self.can_jump, self.jump_cooldown, self.jump_timer, self.is_jumping = True, 0, 180, False
        self.state, self.detection_range, self.reaction_time = 'patrol', 250, 60
        self.animation_list = load_animations('enemy', ['Idle', 'Run'], scale, (255, 0, 0))
        self.frame_index, self.action, self.update_time = 0, 0, pygame.time.get_ticks()
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect(center=(x, y))

    def take_damage(self, damage):
        self.health = max(0, self.health - damage)
        self.alive = self.health > 0

    def ai_behavior(self, player):
        if not (self.alive and player.alive): return
        
        dx = dy = 0
        distance_to_player = abs(self.rect.centerx - player.rect.centerx)
        
        if self.jump_cooldown > 0: self.jump_cooldown -= 1

        if self.state == 'patrol':
            if self.rect.centerx <= self.start_x - self.patrol_distance:
                self.direction, self.flip = 1, False
            elif self.rect.centerx >= self.start_x + self.patrol_distance:
                self.direction, self.flip = -1, True
            
            dx = self.speed * self.direction
            
            if not self.in_air and self.jump_cooldown == 0 and random.random() < enemy1_JUMP_CHANCE and abs(dx) > 0:
                self.vel_y, self.in_air, self.jump_cooldown = JUMP_SPEED * 0.8, True, 60

        if distance_to_player <= self.detection_range:
            self.state = 'chase'

        current_speed = self.speed * 0.9 if self.is_jumping else self.speed
        
        if self.state == 'chase':
            if player.rect.centerx > self.rect.centerx:
                self.direction, self.flip, dx = 1, True, current_speed
            else:
                self.direction, self.flip, dx = -1, False, -current_speed

        self.vel_y = min(10, self.vel_y + GRAVITY)
        dy += self.vel_y

        self.rect.x += dx
        for platform in platform_group:
            if self.rect.colliderect(platform.rect):
                if dx > 0:
                    self.rect.right = platform.rect.left
                    if self.state == 'patrol': self.direction, self.flip = -1, True
                elif dx < 0:
                    self.rect.left = platform.rect.right
                    if self.state == 'patrol': self.direction, self.flip = 1, False

        self.rect.y += dy
        self.in_air = True
        for platform in platform_group:
            if self.rect.colliderect(platform.rect):
                if self.vel_y > 0:
                    self.rect.bottom, self.vel_y, self.in_air, self.is_jumping = platform.rect.top, 0, False, False
                elif self.vel_y < 0:
                    self.rect.top, self.vel_y = platform.rect.bottom, 0

        if self.rect.left < 0:
            self.rect.left = 0
            if self.state == 'patrol': self.direction, self.flip = 1, False
        elif self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
            if self.state == 'patrol': self.direction, self.flip = -1, True

    def update_animation(self):
        old_bottom, old_centerx = self.rect.bottom, self.rect.centerx
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect(centerx=old_centerx, bottom=old_bottom)
        
        if pygame.time.get_ticks() - self.update_time > 50:
            self.update_time = pygame.time.get_ticks()
            self.frame_index = (self.frame_index + 1) % len(self.animation_list[self.action])

    def update_action(self, new_action):
        if new_action != self.action:
            self.action, self.frame_index, self.update_time = new_action, 0, pygame.time.get_ticks()

    def draw(self):
        self.update_action(1 if abs(self.speed) > 0 and self.state in ['chase', 'patrol'] else 0)
        self.update_animation()
        img = pygame.transform.flip(self.image, self.flip, False)
        screen.blit(img, (self.rect.left, self.rect.bottom - img.get_height()))

# ---------- PLAYER CLASS ----------
class Player(pygame.sprite.Sprite):
    def __init__(self, char_type, x, y, scale, speed):
        super().__init__()
        self.alive, self.char_type, self.speed, self.direction, self.flip = True, char_type, speed, 1, False
        self.max_masks, self.current_masks, self.damage_cooldown = 5, 5, 0
        self.vel_y, self.in_air, self.jump_pressed, self.jump_timer = 0, True, False, 0
        self.wall_sliding, self.wall_side, self.wall_slide_speed = False, 0, 2
        self.dashing, self.dash_timer, self.dash_cooldown = False, 0, 0
        self.attacking, self.attack_type, self.attack_timer, self.attack_cooldown, self.attack_rect = False, None, 0, 0, None
        
        self.animation_list = load_animations('player', ['Idle', 'Run', 'Jump', 'Fall', 'Dash', 'Attack', 'Attack_Up', 'Attack_Down'], scale)
        self.frame_index, self.action, self.update_time = 0, 0, pygame.time.get_ticks()
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect(center=(x, y))

    def take_damage(self, damage):
        if self.damage_cooldown == 0 and not self.dashing:
            self.current_masks = max(0, self.current_masks - 1)
            self.damage_cooldown = 90
            if self.current_masks <= 0: self.alive = False

    def create_attack_hitbox(self, attack_type):
        if attack_type == 'up':
            return pygame.Rect(self.rect.centerx - ATTACK_WIDTH // 2, self.rect.top - ATTACK_RANGE, ATTACK_WIDTH, ATTACK_RANGE)
        elif attack_type == 'down':
            return pygame.Rect(self.rect.centerx - ATTACK_WIDTH // 2, self.rect.bottom, ATTACK_WIDTH, ATTACK_RANGE)
        else:
            x = self.rect.right if self.direction == 1 else self.rect.left - ATTACK_RANGE
            return pygame.Rect(x, self.rect.centery - ATTACK_HEIGHT // 2, ATTACK_RANGE, ATTACK_HEIGHT)

    def attack(self):
        if self.attack_cooldown > 0 or self.dashing: return
        
        keys = pygame.key.get_pressed()
        self.attacking, self.attack_cooldown = True, 20
        
        if keys[pygame.K_w]:
            self.attack_type, animation_index = 'up', 6
        elif keys[pygame.K_s] and self.in_air:
            self.attack_type, animation_index = 'down', 7
        else:
            self.attack_type, animation_index = 'side', 5
        
        self.attack_timer = len(self.animation_list[animation_index]) * 40
        self.update_action(animation_index)
        self.attack_rect = self.create_attack_hitbox(self.attack_type)

    def move(self, moving_left, moving_right):
        global waiting_for_reentry, waiting_for_reentry_counter, well_img, well2_img, boss_env_suppressed, roof_restored, middle_platforms_visible
        
        dx = dy = 0
        keys = pygame.key.get_pressed()
        mouse = pygame.mouse.get_pressed()

        if self.damage_cooldown > 0: self.damage_cooldown -= 1

        if mouse[2] and not self.dashing and self.dash_cooldown == 0 and not self.attacking:
            self.dashing, self.dash_timer, self.dash_cooldown, self.vel_y = True, DASH_TIME, DASH_COOLDOWN, 0
            self.update_action(4)

        if self.dashing:
            dx, dy = DASH_SPEED * self.direction, 0
            self.update_action(4)
            self.dash_timer -= 1
            if self.dash_timer <= 0: self.dashing = False
        else:
            if moving_left: dx, self.flip, self.direction = -self.speed, True, -1
            if moving_right: dx, self.flip, self.direction = self.speed, False, 1

            if keys[pygame.K_SPACE]:
                if not self.jump_pressed:
                    self.jump_pressed = True
                    if not self.in_air:
                        self.vel_y, self.in_air, self.jump_timer = JUMP_SPEED, True, MAX_JUMP_TIME
                    elif self.wall_sliding:
                        self.vel_y, self.wall_sliding, self.wall_side, self.jump_timer = JUMP_SPEED, False, 0, MAX_JUMP_TIME
                        if self.wall_side == -1: dx, self.flip, self.direction = self.speed * 4, False, 1
                        else: dx, self.flip, self.direction = -self.speed * 4, True, -1
                else:
                    if self.jump_timer > 0 and not self.wall_sliding:
                        self.vel_y += JUMP_HOLD_FORCE
                        self.jump_timer -= 1
            else:
                self.jump_pressed, self.jump_timer = False, 0

            if self.wall_sliding:
                self.vel_y = min(self.wall_slide_speed, self.vel_y + GRAVITY * 0.3)
            else:
                self.vel_y = min(10, self.vel_y + GRAVITY)
            dy += self.vel_y

        if self.dash_cooldown > 0: self.dash_cooldown -= 1

        if self.attacking:
            self.attack_timer -= 1
            if self.attack_timer <= 0:
                self.attacking, self.attack_type, self.attack_rect = False, None, None
            elif self.attack_rect:
                self.attack_rect = self.create_attack_hitbox(self.attack_type)

        if self.attack_cooldown > 0: self.attack_cooldown -= 1

        self.rect.x += dx
        for platform in platform_group:
            if self.rect.colliderect(platform.rect):
                if dx > 0:
                    self.rect.right = platform.rect.left
                    if self.in_air: self.wall_sliding, self.wall_side = True, 1
                elif dx < 0:
                    self.rect.left = platform.rect.right
                    if self.in_air: self.wall_sliding, self.wall_side = True, -1

        if self.in_air and self.vel_y > 0:
            if self.rect.left <= 0:
                self.rect.left = 0
                self.wall_sliding, self.wall_side = (True, -1) if moving_left else (False, 0)
            elif self.rect.right >= SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                self.wall_sliding, self.wall_side = (True, 1) if moving_right else (False, 0)
            else:
                self.wall_sliding, self.wall_side = False, 0
        else:
            self.rect.left = max(0, self.rect.left)
            self.rect.right = min(SCREEN_WIDTH, self.rect.right)
            self.wall_sliding, self.wall_side = False, 0

        self.rect.y += dy
        self.in_air = True
        for platform in platform_group:
            if self.rect.colliderect(platform.rect):
                if self.vel_y > 0:
                    self.rect.bottom, self.vel_y, self.in_air, self.jump_timer = platform.rect.top, 0, False, 0
                    self.wall_sliding, self.wall_side = False, 0
                elif self.vel_y < 0:
                    self.rect.top, self.vel_y = platform.rect.bottom, 0

        if self.rect.top > SCREEN_HEIGHT - 200:
            try: img_h = self.image.get_height()
            except: img_h = 64
            
            self.rect.top, self.vel_y = -img_h - 300, 0
            
            try:
                well_img, well2_img, boss_env_suppressed, roof_restored = None, None, True, False
                if middle_ground_platform not in platform_group:
                    platform_group.add(middle_ground_platform)
                    middle_platforms_visible = True
                remove_vertical_platforms()
            except: pass
            
            waiting_for_reentry, waiting_for_reentry_counter = True, 120

    def update_animation(self):
        cooldown = 3 if self.action in [5, 6, 7] else 100
        self.image = self.animation_list[self.action][self.frame_index]
        
        if pygame.time.get_ticks() - self.update_time > cooldown:
            self.update_time = pygame.time.get_ticks()
            self.frame_index += 1
            if self.frame_index >= len(self.animation_list[self.action]):
                if self.action in [5, 6, 7]:
                    self.attacking, self.attack_type, self.attack_rect = False, None, None
                self.frame_index = 0
        
        if self.action == 7 and self.attack_rect and self.attacking:
            if self.frame_index >= len(self.animation_list[7]) - 3:
                self.attack_rect.centerx, self.attack_rect.y = self.rect.centerx, self.rect.bottom

    def update_action(self, new_action):
        if new_action != self.action:
            self.action, self.frame_index, self.update_time = new_action, 0, pygame.time.get_ticks()

    def draw(self):
        img = pygame.transform.flip(self.image, self.flip, False)
        draw_x, draw_y = self.rect.left, self.rect.bottom - img.get_height()
        
        if self.action == 5:
            draw_x += 15 if self.direction == 1 else -30
        elif self.action == 7:
            draw_y += 30
        
        if self.damage_cooldown > 0 and self.damage_cooldown % 10 < 5:
            img.set_alpha(128)
        else:
            img.set_alpha(255)
        
        screen.blit(img, (draw_x, draw_y))

def check_combat(player, enemy1):
    if player.attacking and player.attack_rect and enemy1.alive:
        if player.attack_rect.colliderect(enemy1.rect):
            enemy1.take_damage(ATTACK_DAMAGE)
            if player.attack_type == 'down' and player.vel_y >= 0:
                player.vel_y, player.attacking, player.attack_cooldown = -13, False, 15
                player.update_action(0)
            player.attack_rect = None
    
    if enemy1.alive and player.alive and player.rect.colliderect(enemy1.rect):
        player.take_damage(1)

def draw_enemy1_health_bar(enemy1):
    if enemy1.alive and enemy1.health < enemy1.max_health:
        bar_w, bar_h = 50, 5
        bar_x, bar_y = enemy1.rect.centerx - bar_w // 2, enemy1.rect.top - 15
        pygame.draw.rect(screen, RED, (bar_x, bar_y, bar_w, bar_h))
        pygame.draw.rect(screen, GREEN, (bar_x, bar_y, int(bar_w * (enemy1.health / enemy1.max_health)), bar_h))

def draw_main_menu():
    try:
        menu = load_img('img/BG/main_screen.png', (SCREEN_WIDTH, SCREEN_HEIGHT), False)
        screen.blit(menu, (0, 0))
    except:
        screen.fill((50, 50, 100))
        font = pygame.font.Font(None, 74)
        screen.blit(font.render('POXEL', True, WHITE), font.render('POXEL', True, WHITE).get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50)))
        font_small = pygame.font.Font(None, 36)
        screen.blit(font_small.render('Click anywhere to start', True, WHITE), font_small.render('Click anywhere to start', True, WHITE).get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50)))

def restart_game():
    global player, enemy1, roof_restored
    player, enemy1, roof_restored = Player('player', 200, 200, 3, 5), Enemy1(800, 500, 2, 2), False
    try: remove_vertical_platforms()
    except: pass

# ---------- MAIN LOOP ----------
player, enemy1, game_state = Player('player', 200, 200, 3, 5), Enemy1(800, 500, 2, 2), 'menu'

run = True
while run:
    clock.tick(FPS)
    
    if game_state == 'menu':
        draw_main_menu()
    elif game_state == 'playing':
        if waiting_for_reentry or boss_env_suppressed:
            screen.fill((0, 0, 0))
            for platform in platform_group:
                screen.blit(platform.image, platform.rect)
        else:
            draw_bg()
            if not enemy1.alive and not boss_env_suppressed and well_img:
                draw_well()

        player.update_animation()
        player.draw()

        if not enemy1.alive and not boss_env_suppressed and well2_img:
            draw_well_front()

        if player.alive:
            if player.attacking:
                player.update_action(6 if player.attack_type == 'up' else 7 if player.attack_type == 'down' else 5)
            elif player.dashing:
                player.update_action(4)
            elif player.wall_sliding:
                player.update_action(0)
            elif player.in_air:
                player.update_action(2 if player.vel_y < 0 else 3)
            elif moving_left or moving_right:
                player.update_action(1)
            else:
                player.update_action(0)
            player.move(moving_left, moving_right)

        if enemy1.alive:
            enemy1.ai_behavior(player)
            enemy1.draw()
            draw_enemy1_health_bar(enemy1)
        else:
            if not enemy1_dead_handled:
                enemy1_dead()
                enemy1_dead_handled = True
        
        if vertical_platforms_active:
            for vp in vertical_platforms:
                screen.blit(vp.image, getattr(vp, '_visual_rect', vp.rect))

        check_combat(player, enemy1)
        draw_health_masks(player.current_masks, player.max_masks)
        
        if not player.alive:
            restart_game()
            
        if waiting_for_reentry:
            if waiting_for_reentry_counter > 0:
                waiting_for_reentry_counter -= 1
            elif player.rect.top >= 0 and not roof_restored:
                try:
                    if middle_roof_platform not in platform_group:
                        platform_group.add(middle_roof_platform)
                    roof_restored = True
                except: pass
                waiting_for_reentry, waiting_for_reentry_counter = False, 0

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_a: moving_left = True
            elif event.key == pygame.K_d: moving_right = True
            elif event.key == pygame.K_LEFTBRACKET:
                DEBUG_HITBOXES = not DEBUG_HITBOXES
                print(f"DEBUG_HITBOXES={DEBUG_HITBOXES}")
            elif event.key == pygame.K_ESCAPE: run = False
            elif event.key == pygame.K_RIGHTBRACKET:
                enemy1.health, enemy1.alive = 0, False
        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_a: moving_left = False
            elif event.key == pygame.K_d: moving_right = False
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if game_state == 'menu':
                game_state = 'playing'
                restart_game()
            elif game_state == 'playing':
                player.attack()

    if DEBUG_HITBOXES and game_state == 'playing':
        for plat in platform_group:
            pygame.draw.rect(screen, (255, 0, 0), plat.rect, 2)
        pygame.draw.rect(screen, (255, 0, 0), player.rect, 2)
        if enemy1:
            pygame.draw.rect(screen, (255, 0, 0), enemy1.rect, 2)

    pygame.display.update()

pygame.quit()